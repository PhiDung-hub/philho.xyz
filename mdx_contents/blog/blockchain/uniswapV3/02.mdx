---
title: UniswapV3 - Part 02
date: '2023-05-09T00:00:00Z'
modifiedTime: '2023-05-09T00:00:00Z'
summary: Uniswap V3 - Concentrated liquidity - mechanism and implementations
image: 'blogs/blockchain/uniswapV3/cover.webp'
type: BlogPost
---

# Recap

These concepts has been discussed in [previous part](https://philho.xyz/blog/blockchain/uniswapV3/01)

$$
\Large{
\begin{aligned}

  L &= \sqrt{X \times Y} \quad (1) \\

  \Delta Y &= L \times \Delta \sqrt{P} \quad (2) \\

  \Delta X &= L \times \Delta \frac{1}{\sqrt{P}} \quad (3) \\

  p(i) &= 1.0001^i \quad (4)

\end{aligned}
}
$$

We will now proceed with the implementation of the concentrated liquidity mechanism.
This process relies on tick math and fixed point math algorithms,
which can be explored in detail through the [library implementations](https://github.com/Uniswap/v3-core/blob/main/contracts/libraries) available in the official repositories.
For our current discussion, we will be focusing on the following aspects:

- [Position](https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/Position.sol) - Represent an address' liquidity within a tick range (hence concentrated), also tracking fees earned
- [Tick](https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/Tick.sol) - Manage tick processing, focus on `update(...)` function
- [SwapMath](https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/SwapMath.sol) - Compute result of a swap (or trade)

# Position

The source code:

```solidity
// File: .../libraries/Position.sol

// SPDX-License-Identifier: BUSL-1.1
pragma solidity >=0.5.0 <0.8.0;

import './FullMath.sol';
import './FixedPoint128.sol';
import './LiquidityMath.sol';

/// @title Position
/// @notice Positions represent an owner address' liquidity between a lower and upper tick boundary
/// @dev Positions store additional state for tracking fees owed to the position
library Position {
  // info stored for each user's position
  struct Info {
    // the amount of liquidity owned by this position
    uint128 liquidity;
    // fee growth per unit of liquidity as of the last update to liquidity or fees owed
    uint256 feeGrowthInside0LastX128;
    uint256 feeGrowthInside1LastX128;
    // the fees owed to the position owner in token0/token1
    uint128 tokensOwed0;
    uint128 tokensOwed1;
  }

  /// @notice Returns the Info struct of a position, given an owner and position boundaries
  /// @param self The mapping containing all user positions
  /// @param owner The address of the position owner
  /// @param tickLower The lower tick boundary of the position
  /// @param tickUpper The upper tick boundary of the position
  /// @return position The position info struct of the given owners' position
  function get(
    mapping(bytes32 => Info) storage self,
    address owner,
    int24 tickLower,
    int24 tickUpper
  ) internal view returns (Position.Info storage position) {
    position = self[keccak256(abi.encodePacked(owner, tickLower, tickUpper))];
  }

  /// @notice Credits accumulated fees to a user's position
  /// @param self The individual position to update
  /// @param liquidityDelta The change in pool liquidity as a result of the position update
  /// @param feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries
  /// @param feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries
  function update(
    Info storage self,
    int128 liquidityDelta,
    uint256 feeGrowthInside0X128,
    uint256 feeGrowthInside1X128
  ) internal {
    Info memory _self = self;

    uint128 liquidityNext;
    if (liquidityDelta == 0) {
      require(_self.liquidity > 0, 'NP'); // disallow pokes for 0 liquidity positions
      liquidityNext = _self.liquidity;
    } else {
      liquidityNext = LiquidityMath.addDelta(_self.liquidity, liquidityDelta);
    }

    // calculate accumulated fees
    // ADDED NOTE: Q128 = 2^128
    uint128 tokensOwed0 = uint128(
      FullMath.mulDiv(feeGrowthInside0X128 - _self.feeGrowthInside0LastX128, _self.liquidity, FixedPoint128.Q128)
    );
    uint128 tokensOwed1 = uint128(
      FullMath.mulDiv(feeGrowthInside1X128 - _self.feeGrowthInside1LastX128, _self.liquidity, FixedPoint128.Q128)
    );

    // update the position
    if (liquidityDelta != 0) self.liquidity = liquidityNext;
    self.feeGrowthInside0LastX128 = feeGrowthInside0X128;
    self.feeGrowthInside1LastX128 = feeGrowthInside1X128;
    if (tokensOwed0 > 0 || tokensOwed1 > 0) {
      // overflow is acceptable, have to withdraw before you hit type(uint128).max fees
      self.tokensOwed0 += tokensOwed0;
      self.tokensOwed1 += tokensOwed1;
    }
  }
}
```

From the above implementations, there are a few notes:

- A position stores `L` and total fee accumulated for both tokens.
- A position is indexed by `owner, tickLower, tickUpper` using keccak256 hash.
- As $\Delta X$ and $\Delta Y$ both involves common factor $L$ [from (2) and (3)], it's more efficient to use fee per unit of liquidity
  and derive the total amount once every update, as seen in [pool contract](https://github.com/Uniswap/v3-core/blob/main/contracts/UniswapV3Pool.sol#L379).
  `feeGrowthInside...` is padded with 128 "0" bits to make `mulDiv` works ([`mulDiv(a, b, denominator)`](https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol#L14) calculate `a x b / denominator` with full precision).

# Tick

