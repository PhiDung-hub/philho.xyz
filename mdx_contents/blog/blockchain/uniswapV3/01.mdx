---
title: UniswapV3 - Part 01
date: '2023-05-09T00:00:00Z'
modifiedTime: '2023-05-09T00:00:00Z'
summary: Uniswap V3 Introduction - Discover the innovative liquidity model, essential concepts, and mathematical formulas.
image: 'blogs/blockchain/uniswapV3/cover.webp'
type: BlogPost
---

# Introduction and resources

This is the first part of my series titled "Uniswap V3". First and foremost, here are some good references to get started:

1. [Uniswap V2 whitepaper](https://uniswap.org/whitepaper.pdf) and [docs](https://docs.uniswap.org/contracts/v2/overview)
2. [Comprehensive tutorial](https://uniswapv3book.com/docs/introduction/uniswap-v3/) from [Ivan Kuznetsov](https://github.com/Jeiwan)
3. [Official whitepaper](https://uniswap.org/whitepaper-v3.pdf), [official docs](https://docs.uniswap.org/contracts/v3/overview) and [source code](https://github.com/Uniswap/v3-core)

# Liquidity model

Comparing to Uniswap V2, V3 uses the same constant product $X \times Y = K$ curve.
However, Uniswap V3 augment the liquidity model, i.e. introducing new concepts to support concentrated liquidity provision.

## 1. Liquidity Amount

Let X, Y be the price of two tokens in a liquidity pool, respectively. In V3, the amount of liquidity $L$, represented by an **uint128** is defined as:

$$
\tag{1}

\Large{
  L \overset{\Delta} = \sqrt{X \times Y}
}
$$

With same price defined as in V2 ($P = \dfrac{Y}{X}$), the following can be derived:

$$
\tag{2}

\Large{
  \Delta Y = L \times \Delta \sqrt{P}
}
$$

$$
\tag{3}

\Large{
  \Delta X = L \times \Delta \frac{1}{\sqrt{P}}
}
$$

### Proof (2-3)

For $\Delta Y\ (2)$:

$$
\large{
  \begin{aligned}

  L \times \Delta \sqrt{P} &= \sqrt{XY} \times ( \sqrt{\frac{Y_1}{X_1}} - \sqrt{\frac{Y_2}{X_2}} ) \\
  &= \sqrt{\frac {Y_1^2 \cdot X_1} {X_1}} - \sqrt{\frac {Y_2^2 \cdot X_2} {X_2}} \quad [X_1 Y_1 = X_2 Y_2 = XY] \\
  &= Y_1 - Y_2 = \Delta Y \quad (Q.E.D)

  \end{aligned}
}
$$

Similarly, for $\Delta X \ (3)$:

$$
\large{
  \begin{aligned}

  L \times \Delta \sqrt {\frac{1}{P}}

  &= \sqrt{XY} \times ( \sqrt{\frac{X_1}{Y_1}} - \sqrt{\frac{X_2}{Y_2}} ) \\

  &= \sqrt{\frac {X_1^2 \cdot Y_1} {Y_1}} - \sqrt{\frac {X_2^2 \cdot Y_2} {Y_2}} \quad [X_1 Y_1 = X_2 Y_2 = XY] \\

  &= X_1 - X_2 = \Delta X \quad (Q.E.D)

  \end{aligned}
}
$$

### Discussion: about Square root of price

All the above formulas involves $\sqrt{P}$ and $L$, a natural approach is utilizing these 2 variables to manage liquidity and price for the AMM model.

However, this wasn't always the case. During first days, V3 was using [`Babylonian.sqrt`](https://github.com/Uniswap/solidity-lib/blob/master/contracts/libraries/Babylonian.sol) algotihm to approximate reserve values.
**uint256**, **uint128**, and **UQ128.128** ([Unsigned Q number](<https://en.wikipedia.org/wiki/Q_(number_format)>) was being used for liqiduity and price calculation,
as evidence in [PriceMath.sol](https://github.com/Uniswap/v3-core/blob/c09c892f59e08783e2415d1957c67979a4c7dccc/contracts/libraries/PriceMath.sol).

[`SqrtPriceMath`](https://docs.uniswap.org/contracts/v3/reference/core/libraries/SqrtPriceMath) was first introduced on [commit 4724f148f5eb626d07d68e485a0a7a45103ee448](https://github.com/Uniswap/v3-core/commit/4724f148f5eb626d07d68e485a0a7a45103ee448) and regularly updated to use **UQ64.96** as of present.
Using the new approach provides better granularity and higher precision compared to a linear approximation (using Babylonian sqrt) pricing model.

## 2. Tick system

As the AMM operates on percentage, e.g. fee is 0.01% | 0.05% | 0.3%, and we traders love using ticks. Uniswap V3 implements a tick system that is:

$$
\tag{4}

\Large{
  Tick_{i} \overset{\Delta} = 1.0001^i \quad \text{[1 tick = 0.01\%]}
}
$$

### Tick range

As $\sqrt{P}$ is [$Q64.96$](<https://en.wikipedia.org/wiki/Q_(number_format)>) formatted, the tick range is

$$
\large{
  \begin{aligned}
  [\log_{1.0001}P_{min}, \ log_{1.0001}P_{max}]

  &= [\log_{1.0001}{2^{-96 \times 2}}, \ \log_{1.0001}{2^{64 \times 2}}] \\

  &\overset{\Delta} {\approx} [\log_{1.0001}{2^{-128}}, \ \log_{1.0001}{2^{128}}] \quad \text{(for symmetry)} \\

  &= [-887272, 887272]
  \end{aligned}
}
$$

Same reasoning can be found in [this discussion](https://ethereum.stackexchange.com/questions/144793/why-does-uniswap-v3-use-ticks-887220-887220-to-represent-the-price-range-0-%E2%88%9E) (though the value was 887220).
And the [official values](https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/TickMath.sol#L9) can be verified as derived.

### Tick representation

With this range, tick values can be packed into 21-bits signed integers.
Thus the [official implementation](https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/TickMath.sol) uses **int24** for ticks (size should fit in bytes).

With the tick system, our next step is to provide a mechanism to manage liquidity provision between 2 ticks values.
For example, a user who wish to provide liquidity between tick $[-1000, 1000]$ suppose to trade their tokens and earn fee while $P \in [0.904842, 1.105165]$,
and do nothing otherwise.

## 3. Liquidity curve

With the tick system and liquidity amount defined in previous section. Let's _token0_ and _token1_ be 2 tokens in our liquidity pool.
The liquidity density, i.e. the amount of liquidity within a price/tick range is:

$$
\tag{5}

\Large{
  \lambda \overset{\Delta}= \frac {\delta Y}{\delta \sqrt{P}} \\
}
$$

$$
\begin{aligned}

\text{where }
&\delta \sqrt{P} \text{ - quantum (sqrt) price range, i.e. a tick for V3} \\
&\delta Y \text{ - liquidity within the range, i.e. amount of token1 tradable within range} [\sqrt P, \sqrt P + \delta \sqrt P].

\end{aligned}
$$

Then liquidity curve is the $\lambda - P$ curve.

### Uniswap V2

For V2, every liquidity provider is exposed to the whole $0 \rightarrow \infty$ range. Meaning liquidity is evenly distributed and $\lambda - P$ will be a straight line.

For example, let take a liquidity pool with initial reserve of **100 token A** (token0) and **100 token B** (token1). The liquidity locked in first tick is

$$
\begin{aligned}

\bullet \ \delta L
&= \Delta_{0 \rightarrow 1} Y \\
&= L \times \Delta_{0  \rightarrow 1} \sqrt{P} \\
&= 100 \times (\sqrt{1.0001} - 1) \\
&\approx 0.05  \\

\bullet \ \delta \sqrt{P} &= \Delta_{0 \rightarrow 1} \sqrt{P} \\

\end{aligned}
$$

<div className="py-1"></div>

$$
\large {
  \Rightarrow
  \lambda_{0 \rightarrow 1} = \frac {\Delta_{0 \rightarrow 1} Y} {\Delta_{0 \rightarrow 1} \sqrt{P}} = 100
}
$$

In fact, $\lambda_{i \rightarrow i+1} = L \ \forall i$ as derived above. This mean liquidity is uniformly distributed for V2.

### Uniswap V3

In V2, there was an issue with stable coin pools. Users expected to be able to swap stable coins with minimal slippage.
However, in V2, the slippage for such swaps was quite high, around 0.8% for 1% of the total value locked (TVL) in the pool.
This means that if someone wanted to swap $1M USDC for DAI in a pool that had a total value of $100M in both DAI and USDC,
they would have to pay a staggering $80,000 in fees.

This issue is solved by concentrated liquidity in V3.

<Quote author="Uniswap V3 white-paper" className="my-2">

"...We call liquidity concentrated to a finite range a position. A position only needs to maintain enough reserves to support trading within
its range, and therefore can act like a constant product pool with larger reserves (we call these the virtual reserves) within that
range.

Specifically, a position only needs to hold enough of asset X to cover price movement to its upper bound,
because upwards price movement corresponds to depletion of the X reserves.
Similarly, it only needs to hold enough of asset Y to cover price movement to its lower bound.

When the price exits a position’s range, the position’s liquidity is no longer active, and no longer earns fees.
At that point, its liquidity is composed entirely of a single asset, because the reserves of the other asset must have been entirely depleted.
If the price ever reenters the range, the liquidity becomes active again..."

</Quote>

<div className="block md:flex justify-center align-center py-2">
  <Image
    src="/blogs/blockchain/uniswapV3/01/virtual_reserve.webp"
    className="mx-auto"
    wrapperClassName="pr-2"
    width="576"
    height="576"
    alt="virutal reserve"
    caption="Virtual reserve"
  />
  <Image
    src="/blogs/blockchain/uniswapV3/01/real_reserve.webp"
    className="mx-auto"
    wrapperClassName="pl-2"
    width="551"
    height="551"
    alt="real vs virtual reserve"
    caption="Real vs Virtual reserve"
  />
</div>

If considering a curve bounded by 2 points $[a, b]$ as above figures.
Virtual reserve is the reserve in the pool if we extended it to infinity, whereas real reserve is the actual token reserves available within specified range, i.e. $[a, b]$

Then "concentrated liquidity" essential mean splitting each tick into a virtual reserve and combine them to form the complete liquidity curve.
Doing so will result in more efficient captical allocation $\rightarrow$ more fee earned and less slippage.

In summary, the curve can be visualised as follow:

<Image
  src="/blogs/blockchain/uniswapV3/liquidity_curve.webp"
  className="py-2"
  width="1500"
  height="600"
  alt="liquidty curve"
  caption="Liquidity curve [visualization from V3-whitepaper]"
/>

# What's next?

Thank you for completing Part 1 of my Uniswap V3 series!
In the next installment, we'll dive into the implementation details.
Stay tuned for Part 2 and cheers!
