[
  {
    "title": "Intro to Rust",
    "date": "2022-03-26T00:00:00Z",
    "modifiedTime": "2022-03-26T00:00:00Z",
    "summary": "Basics introduction about Rust set up",
    "image": "blogs/rust/cover.webp",
    "body": {
      "raw": "\n# Get started\n\nThe most useful resource to kickstart rust development is [Rust book](https://doc.rust-lang.org/book/v)\n\n## Linux, MacOS, or WSL2 Linux Distro\n\n```bash\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\n\nYou should now be equipped with:\n\n- [`rustup`](https://rust-lang.github.io/rustup/) - Toolchain manager for rust programmign language, it enables you to switch between or update `rustc` & `cargo`.\n- [`cargo`](https://doc.rust-lang.org/cargo/) - The package manager for rust, similar to what `yarn` or `npm` do for `node.js`.\n- [`rustc`](https://doc.rust-lang.org/stable/rustc/) - The rust compiler, it producees binary code from your source code. This is similar `gcc/g++` for C++, most of the time you don't invoke it directly but rather run & build rust program through a build tool (like `cmake`). For rust, our friend is `cargo`.\n\n## Windows\n\nDownload the installer by following [this instruction](https://www.rust-lang.org/tools/install). You should be ready in no time.\n\n## Build from source\n\nClone the rustup repo [here](https://github.com/rust-lang/rustup). If you didn't have `cargo`, double check `rustup-init.sh` script, execute it, then `cargo run --release`, else just run the command. More info [here](https://rust-lang.github.io/rustup/installation/other.html#msvc). **Becareful! This will supersede any pre-existing tools chains**.\n\n# First glance\n\nWe will scan through some of important concepts & features of Rust. A good place to references is [Rust standard library](https://doc.rust-lang.org/stable/std)\n\n## String\n\nAt least multiple types of strings in Rust.\n\n1. `str` - string slice, we don't normally use this, [refence here](https://doc.rust-lang.org/std/primitive.str.html)\n2. `&str` - borrowed string slice, made up of a pointer to an array of bytes. Data in `&str` is immutable. String CAN'T be index by\n   character position (because Unicode characters may contain multiple bytes, what display is unicode graphemes instead of scalar/utf-8).\n3. `String` - a vector of bytes, contains data, len, and capacity. Data in `String` is mutable.\n\n| Example  | Description       | Rules |\n| -------- | ----------------- | ----- |\n| $value   | Lowercase         | ✅    |\n| $Value   | Uppercase         | ✅    |\n| $\\_value | Underscore        | ✅    |\n| $1value  | Start from number | ❌    |\n\n## Ownership\n\nOwnership is what makes Rust compiler run on steroids, making it one of the safest system programming languages out there.\nThere are 3 rules regarding ownership:\n\n1. Each value has an owner\n2. Only one owner - it can be borrowed.\n3. If lifetime of value expired (go out of scope), it ownership is dropped.\n\nAn example of ownership:\n\n```rust\nint main() {\n  let s1 = String::from(\"hello\"); // Initialize and given ownership of this string\n  let s2 = s1; // Value is moved here // ownership is transferred to s2.\n  // println!(\"{}\", s1); // Invalid since s2 ownerd the value now\n  println!(\"{}\", s2); // This is ok\n}\n```\n\n## Pointer, Box & Smart pointers\n\nAll values in Rust are stack allocated by default (continous/linear, high-speed access, [more info](https://www.guru99.com/stack-vs-heap.html)).\nNevertheless, since the stack is fixed size so compilation wouldn't work for recusive data structures such as Linkedlists, Array, etc.. where\ndata size is unknown at compilation time.\n\n- Values can be boxed and allocates on the heap with `std::Box<T>`, where dynamic memory\n  allocation can happen.\n- A box is a smart pointer to a heap value of type `T`. And a smart pointer is a pointer with additional features like automatic\n  memory management or bounds checking\n  - Conceptualize by C++, inspired from Simula67 `element` - a pointer without `null` ([history](https://en.wikipedia.org/wiki/Smart_pointer#history)).\n  - For example, in C++11, `std::unique_ptr<Type> Func()` makes explicit that caller should takes ownership of the result, and C++ runtime ensures that memory will be reclaimed automatically.\n  - <strong>For Rust, </strong> a smart pointer is defined mostly as a struct that\n    implements `Deref` - , `Drop` traits. The concept is well described in [official\n    book](https://doc.rust-lang.org/book/ch15-00-smart-pointers.html). You may find this [explanation](https://youtu.be/KYJ95TxEC18) helpful.\n\n<br></br>\nAn example of `Box` from the book, noticing box always takes 8 bytes.\n\n```rust\nuse std::mem;\n\n#[allow(dead_code)]\n#[derive(Debug, Clone, Copy)]\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\n// A Rectangle can be specified by where its top left and bottom right corners are in space\n#[allow(dead_code)]\nstruct Rectangle {\n    top_left: Point,\n    bottom_right: Point,\n}\n\nfn origin() -> Point {\n    Point { x: 0.0, y: 0.0 }\n}\n\nfn boxed_origin() -> Box<Point> {\n    // Allocate this point on the heap, and return a pointer to it\n    Box::new(Point { x: 0.0, y: 0.0 })\n}\n\nfn main() {\n    // Stack allocated variables\n    let point: Point = origin();\n    let rectangle: Rectangle = Rectangle {\n        top_left: origin(),\n        bottom_right: Point { x: 3.0, y: -4.0 }\n    };\n\n    // Heap allocated rectangle\n    let boxed_rectangle: Box<Rectangle> = Box::new(Rectangle {\n        top_left: origin(),\n        bottom_right: Point { x: 3.0, y: -4.0 },\n    });\n\n    // The output of functions can be boxed\n    let boxed_point: Box<Point> = Box::new(origin());\n\n    // Double indirection\n    let box_in_a_box: Box<Box<Point>> = Box::new(boxed_origin());\n\n    println!(\"Point occupies {} bytes on the stack\",\n             mem::size_of_val(&point));\n    println!(\"Rectangle occupies {} bytes on the stack\",\n             mem::size_of_val(&rectangle));\n\n    // box size == pointer size\n    println!(\"Boxed point occupies {} bytes on the heap\",\n             mem::size_of_val(&boxed_point));\n    println!(\"Boxed rectangle occupies {} bytes on the heap\",\n             mem::size_of_val(&boxed_rectangle));\n    println!(\"Boxed box occupies {} bytes on the heap\",\n             mem::size_of_val(&box_in_a_box));\n\n    // Copy the data contained in `boxed_point` into `unboxed_point`\n    let unboxed_point: Point = *boxed_point;\n    println!(\"Unboxed point occupies {} bytes on the stack\",\n             mem::size_of_val(&unboxed_point));\n}\n```\n\n```bash\nOutput >>\n\nPoint occupies 16 bytes on the stack\nRectangle occupies 32 bytes on the stack\nBoxed point occupies 8 bytes on the heap\nBoxed rectangle occupies 8 bytes on the heap\nBoxed box occupies 8 bytes on the heap\nUnboxed point occupies 16 bytes on the stack\n```\n\n## References\n\n- [O'Reilly rust crash course](https://learning.oreilly.com/videos/ultimate-rust-crash/9781800563902/)\n\n",
      "code": "var Component=(()=>{var h=Object.create;var o=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var b=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),f=(t,e)=>{for(var i in e)o(t,i,{get:e[i],enumerable:!0})},c=(t,e,i,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of p(e))!g.call(t,r)&&r!==i&&o(t,r,{get:()=>e[r],enumerable:!(l=u(e,r))||l.enumerable});return t};var x=(t,e,i)=>(i=t!=null?h(m(t)):{},c(e||!t||!t.__esModule?o(i,\"default\",{value:t,enumerable:!0}):i,t)),y=t=>c(o({},\"__esModule\",{value:!0}),t);var a=b((R,s)=>{s.exports=_jsx_runtime});var v={};f(v,{default:()=>k,frontmatter:()=>w});var n=x(a()),w={title:\"Intro to Rust\",date:\"2022-03-26T00:00:00Z\",modifiedTime:\"2022-03-26T00:00:00Z\",summary:\"Basics introduction about Rust set up\",image:\"blogs/rust/cover.webp\",type:\"BlogPost\"};function d(t){let e=Object.assign({h1:\"h1\",p:\"p\",a:\"a\",h2:\"h2\",pre:\"pre\",code:\"code\",ul:\"ul\",li:\"li\",strong:\"strong\",ol:\"ol\",table:\"table\",thead:\"thead\",tr:\"tr\",th:\"th\",tbody:\"tbody\",td:\"td\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h1,{children:\"Get started\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The most useful resource to kickstart rust development is \",(0,n.jsx)(e.a,{href:\"https://doc.rust-lang.org/book/v\",children:\"Rust book\"})]}),`\n`,(0,n.jsx)(e.h2,{children:\"Linux, MacOS, or WSL2 Linux Distro\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-bash\",children:`curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"You should now be equipped with:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.a,{href:\"https://rust-lang.github.io/rustup/\",children:(0,n.jsx)(e.code,{children:\"rustup\"})}),\" - Toolchain manager for rust programmign language, it enables you to switch between or update \",(0,n.jsx)(e.code,{children:\"rustc\"}),\" & \",(0,n.jsx)(e.code,{children:\"cargo\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.a,{href:\"https://doc.rust-lang.org/cargo/\",children:(0,n.jsx)(e.code,{children:\"cargo\"})}),\" - The package manager for rust, similar to what \",(0,n.jsx)(e.code,{children:\"yarn\"}),\" or \",(0,n.jsx)(e.code,{children:\"npm\"}),\" do for \",(0,n.jsx)(e.code,{children:\"node.js\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.a,{href:\"https://doc.rust-lang.org/stable/rustc/\",children:(0,n.jsx)(e.code,{children:\"rustc\"})}),\" - The rust compiler, it producees binary code from your source code. This is similar \",(0,n.jsx)(e.code,{children:\"gcc/g++\"}),\" for C++, most of the time you don't invoke it directly but rather run & build rust program through a build tool (like \",(0,n.jsx)(e.code,{children:\"cmake\"}),\"). For rust, our friend is \",(0,n.jsx)(e.code,{children:\"cargo\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Windows\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Download the installer by following \",(0,n.jsx)(e.a,{href:\"https://www.rust-lang.org/tools/install\",children:\"this instruction\"}),\". You should be ready in no time.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Build from source\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Clone the rustup repo \",(0,n.jsx)(e.a,{href:\"https://github.com/rust-lang/rustup\",children:\"here\"}),\". If you didn't have \",(0,n.jsx)(e.code,{children:\"cargo\"}),\", double check \",(0,n.jsx)(e.code,{children:\"rustup-init.sh\"}),\" script, execute it, then \",(0,n.jsx)(e.code,{children:\"cargo run --release\"}),\", else just run the command. More info \",(0,n.jsx)(e.a,{href:\"https://rust-lang.github.io/rustup/installation/other.html#msvc\",children:\"here\"}),\". \",(0,n.jsx)(e.strong,{children:\"Becareful! This will supersede any pre-existing tools chains\"}),\".\"]}),`\n`,(0,n.jsx)(e.h1,{children:\"First glance\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"We will scan through some of important concepts & features of Rust. A good place to references is \",(0,n.jsx)(e.a,{href:\"https://doc.rust-lang.org/stable/std\",children:\"Rust standard library\"})]}),`\n`,(0,n.jsx)(e.h2,{children:\"String\"}),`\n`,(0,n.jsx)(e.p,{children:\"At least multiple types of strings in Rust.\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"str\"}),\" - string slice, we don't normally use this, \",(0,n.jsx)(e.a,{href:\"https://doc.rust-lang.org/std/primitive.str.html\",children:\"refence here\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"&str\"}),\" - borrowed string slice, made up of a pointer to an array of bytes. Data in \",(0,n.jsx)(e.code,{children:\"&str\"}),` is immutable. String CAN'T be index by\ncharacter position (because Unicode characters may contain multiple bytes, what display is unicode graphemes instead of scalar/utf-8).`]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"String\"}),\" - a vector of bytes, contains data, len, and capacity. Data in \",(0,n.jsx)(e.code,{children:\"String\"}),\" is mutable.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.table,{children:[(0,n.jsx)(e.thead,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.th,{children:\"Example\"}),(0,n.jsx)(e.th,{children:\"Description\"}),(0,n.jsx)(e.th,{children:\"Rules\"})]})}),(0,n.jsxs)(e.tbody,{children:[(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"$value\"}),(0,n.jsx)(e.td,{children:\"Lowercase\"}),(0,n.jsx)(e.td,{children:\"\\u2705\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"$Value\"}),(0,n.jsx)(e.td,{children:\"Uppercase\"}),(0,n.jsx)(e.td,{children:\"\\u2705\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"$_value\"}),(0,n.jsx)(e.td,{children:\"Underscore\"}),(0,n.jsx)(e.td,{children:\"\\u2705\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"$1value\"}),(0,n.jsx)(e.td,{children:\"Start from number\"}),(0,n.jsx)(e.td,{children:\"\\u274C\"})]})]})]}),`\n`,(0,n.jsx)(e.h2,{children:\"Ownership\"}),`\n`,(0,n.jsx)(e.p,{children:`Ownership is what makes Rust compiler run on steroids, making it one of the safest system programming languages out there.\nThere are 3 rules regarding ownership:`}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Each value has an owner\"}),`\n`,(0,n.jsx)(e.li,{children:\"Only one owner - it can be borrowed.\"}),`\n`,(0,n.jsx)(e.li,{children:\"If lifetime of value expired (go out of scope), it ownership is dropped.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"An example of ownership:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-rust\",children:`int main() {\n  let s1 = String::from(\"hello\"); // Initialize and given ownership of this string\n  let s2 = s1; // Value is moved here // ownership is transferred to s2.\n  // println!(\"{}\", s1); // Invalid since s2 ownerd the value now\n  println!(\"{}\", s2); // This is ok\n}\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Pointer, Box & Smart pointers\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"All values in Rust are stack allocated by default (continous/linear, high-speed access, \",(0,n.jsx)(e.a,{href:\"https://www.guru99.com/stack-vs-heap.html\",children:\"more info\"}),`).\nNevertheless, since the stack is fixed size so compilation wouldn't work for recusive data structures such as Linkedlists, Array, etc.. where\ndata size is unknown at compilation time.`]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Values can be boxed and allocates on the heap with \",(0,n.jsx)(e.code,{children:\"std::Box<T>\"}),`, where dynamic memory\nallocation can happen.`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"A box is a smart pointer to a heap value of type \",(0,n.jsx)(e.code,{children:\"T\"}),`. And a smart pointer is a pointer with additional features like automatic\nmemory management or bounds checking`,`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Conceptualize by C++, inspired from Simula67 \",(0,n.jsx)(e.code,{children:\"element\"}),\" - a pointer without \",(0,n.jsx)(e.code,{children:\"null\"}),\" (\",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Smart_pointer#history\",children:\"history\"}),\").\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"For example, in C++11, \",(0,n.jsx)(e.code,{children:\"std::unique_ptr<Type> Func()\"}),\" makes explicit that caller should takes ownership of the result, and C++ runtime ensures that memory will be reclaimed automatically.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(\"strong\",{children:\"For Rust, \"}),` a smart pointer is defined mostly as a struct that\nimplements `,(0,n.jsx)(e.code,{children:\"Deref\"}),\" - , \",(0,n.jsx)(e.code,{children:\"Drop\"}),\" traits. The concept is well described in \",(0,n.jsx)(e.a,{href:\"https://doc.rust-lang.org/book/ch15-00-smart-pointers.html\",children:`official\nbook`}),\". You may find this \",(0,n.jsx)(e.a,{href:\"https://youtu.be/KYJ95TxEC18\",children:\"explanation\"}),\" helpful.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(\"br\",{}),`\n`,(0,n.jsxs)(e.p,{children:[\"An example of \",(0,n.jsx)(e.code,{children:\"Box\"}),\" from the book, noticing box always takes 8 bytes.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-rust\",children:`use std::mem;\n\n#[allow(dead_code)]\n#[derive(Debug, Clone, Copy)]\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\n// A Rectangle can be specified by where its top left and bottom right corners are in space\n#[allow(dead_code)]\nstruct Rectangle {\n    top_left: Point,\n    bottom_right: Point,\n}\n\nfn origin() -> Point {\n    Point { x: 0.0, y: 0.0 }\n}\n\nfn boxed_origin() -> Box<Point> {\n    // Allocate this point on the heap, and return a pointer to it\n    Box::new(Point { x: 0.0, y: 0.0 })\n}\n\nfn main() {\n    // Stack allocated variables\n    let point: Point = origin();\n    let rectangle: Rectangle = Rectangle {\n        top_left: origin(),\n        bottom_right: Point { x: 3.0, y: -4.0 }\n    };\n\n    // Heap allocated rectangle\n    let boxed_rectangle: Box<Rectangle> = Box::new(Rectangle {\n        top_left: origin(),\n        bottom_right: Point { x: 3.0, y: -4.0 },\n    });\n\n    // The output of functions can be boxed\n    let boxed_point: Box<Point> = Box::new(origin());\n\n    // Double indirection\n    let box_in_a_box: Box<Box<Point>> = Box::new(boxed_origin());\n\n    println!(\"Point occupies {} bytes on the stack\",\n             mem::size_of_val(&point));\n    println!(\"Rectangle occupies {} bytes on the stack\",\n             mem::size_of_val(&rectangle));\n\n    // box size == pointer size\n    println!(\"Boxed point occupies {} bytes on the heap\",\n             mem::size_of_val(&boxed_point));\n    println!(\"Boxed rectangle occupies {} bytes on the heap\",\n             mem::size_of_val(&boxed_rectangle));\n    println!(\"Boxed box occupies {} bytes on the heap\",\n             mem::size_of_val(&box_in_a_box));\n\n    // Copy the data contained in \\`boxed_point\\` into \\`unboxed_point\\`\n    let unboxed_point: Point = *boxed_point;\n    println!(\"Unboxed point occupies {} bytes on the stack\",\n             mem::size_of_val(&unboxed_point));\n}\n`})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-bash\",children:`Output >>\n\nPoint occupies 16 bytes on the stack\nRectangle occupies 32 bytes on the stack\nBoxed point occupies 8 bytes on the heap\nBoxed rectangle occupies 8 bytes on the heap\nBoxed box occupies 8 bytes on the heap\nUnboxed point occupies 16 bytes on the stack\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"References\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://learning.oreilly.com/videos/ultimate-rust-crash/9781800563902/\",children:\"O'Reilly rust crash course\"})}),`\n`]})]})}function _(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(d,t)})):d(t)}var k=_;return y(v);})();\n;return Component;"
    },
    "_id": "blog/example_blog.mdx",
    "_raw": {
      "sourceFilePath": "blog/example_blog.mdx",
      "sourceFileName": "example_blog.mdx",
      "sourceFileDir": "blog",
      "contentType": "mdx",
      "flattenedPath": "blog/example_blog"
    },
    "type": "BlogPost",
    "slug": "example_blog"
  }
]